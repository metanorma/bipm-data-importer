#!/usr/bin/env ruby

require_relative '../lib/bipm-data-importer'

BASE_DIR = "data"
a = Mechanize.new

meetings_en = VCR.use_cassette 'cipm/cipm-meetings' do
  a.get "https://www.bipm.org/en/committees/ci/cipm/meetings"
end

meetings_fr = VCR.use_cassette 'cipm/cipm-meetings-fr' do
  a.get "https://www.bipm.org/fr/committees/ci/cipm/meetings"
end

resolutions = {}
%w[en fr].each do |meeting_lang|
  meeting_lang_sfx     = (meeting_lang == 'fr') ? "-fr" : ""
  meeting_lang_sfx_dir = (meeting_lang == 'fr') ? "-fr" : "-en"

  meetings = (meeting_lang == 'en') ? meetings_en : meetings_fr

  index = {
            "meetings" => {"fr" => [], "en" => []}, 
            "decisions" => {"fr" => [], "en" => []},
          }

  meetings.css('.meetings-list__item').each do |meeting_div|
    date = Bipm::Data::Importer::Common.extract_date(meeting_div.at_css('.meetings-list__informations-date').text)

    title = meeting_div.at_css('.meetings-list__informations-title').text.strip
    href = meeting_div.at_css('.meetings-list__informations-title').attr('href')

    ident = href.split('/cipm/').last.gsub('/', '.')
    yr = href.include?("/wg/") ? nil : href.split('-').last
    meeting_id = href.include?("/wg/") ? nil : begin
      parts = href.split("/").last.split("-")
      if parts.length == 2
        # Only the number
        parts[0]
      else
        parts[0] + parts[1].sub("_", "-")
      end
    end

    meeting = VCR.use_cassette "cipm/cipm-meeting-#{ident}#{meeting_lang_sfx}" do
      a.get href
    end

    # meeting logic, as in for the `meetings-xx` structure
    # this structure contains recommendations

    if yr
      has_recommendations = false

      pdf = Bipm::Data::Importer::Common.extract_pdf(meeting, meeting_lang)

      h = {
        "metadata" => {
          "title" => title,
          "identifier" => meeting_id,
          "date" => date.to_s,
          "source" => "BIPM - Pavillon de Breteuil",
          "url" => meeting.uri.to_s,
        }
      }

      h["pdf"] = pdf if pdf

      h["resolutions"] = meeting.css(".bipm-resolutions .publications__content").map do |res_div;href|
        href = res_div.at_css('a').attr('href').gsub('/web/guest/', "/#{meeting_lang}/")
        # error: https://www.bipm.org/fr/committees/ci/cipm/104-_1-2015 has wrong references to Recommandations
        href = href.gsub('/104-2015/', '/104-_1-2015/')

        res_id = href.split("-").last.to_i
        res = VCR.use_cassette("cipm/cipm-recommendation-#{yr}-#{res_id}#{meeting_lang_sfx}") do
          a.get href
        end

        has_recommendations = true

        Bipm::Data::Importer::Common.parse_resolution(res, res_id, date, :cipm, meeting_lang, "recommendation?")
      end

      index["meetings"][meeting_lang] << h
    end

    # decisions logic, as in for the `decisions-xx` structure
    # this structure contains decisions

    if meeting_id
      h = {
        "metadata" => {
          "title" => title,
          "identifier" => meeting_id,
          "date" => date.to_s,
          "source" => "BIPM - Pavillon de Breteuil",
          "url" => meeting.uri.to_s
        }
      }

      h["resolutions"] = meeting.css('.bipm-decisions .decisions').map do |titletr|
        r = {
          "dates" => [date.to_s],
          "subject" => "CIPM",
          "type" => "decision",
          "title" => titletr.at_css('.title-third').text.strip,
          "identifier" => "#{titletr.attr('data-meeting')}-#{titletr.attr('data-number')}",
          "url" => meeting.uri.to_s,
          #TODO: "reference" => meeting.uri.merge(titletr.attr('data-link')).to_s,

          "categories" => JSON.parse(titletr.attr('data-decisioncategories')).map(&:strip).uniq,

          "considerations" => [],
          "actions" => [],
        }

        contenttr = Nokogiri::HTML(titletr.attr('data-text'))

        Bipm::Data::Importer::Common.replace_links contenttr, meeting, meeting_lang

        part = Bipm::Data::Importer::Common.ng_to_string(contenttr)
        part = part.gsub(%r"<a name=\"haut\">(.*?)</a>"m, '\1')
        parse = Nokogiri::HTML(part).text.strip

        parse =~ /\A(((the|le|la|Le secrétaire du|Le président du|Les membres du|Le directeur du) +[BC][IG]PM( Director| President| Secretary| members)?|Dr May|W\.E\. May)[, ]+)/i
        subject = $1
        if subject
          parse = parse[subject.length..-1]
          part = part.gsub(/\A(<html><body>\n*<p>)#{Regexp.escape subject}/, '\1')
          # Note: we set "CIPM" as the subject for all CIPM decisions
          # r['subject'] = subject.strip
        end

        xparse = parse

        (1..1024).each do |pass|
          Bipm::Data::Importer::CONSIDERATIONS.any? do |k,v|
            if xparse =~ /\A#{Bipm::Data::Importer::PREFIX}#{k}\b/i
              r["considerations"] << {
                "type" => v,
                "date_effective" => date.to_s,
                "message" => Bipm::Data::Importer::Common.format_message(part),
              }
            end
          end && break

          Bipm::Data::Importer::ACTIONS.any? do |k,v|
            if xparse =~ /\A#{Bipm::Data::Importer::PREFIX}#{k}\b/i
              r["actions"] << {
                "type" => v,
                "date_effective" => date.to_s,
                "message" => Bipm::Data::Importer::Common.format_message(part),
              }
            end
          end && break

          case pass
          when 1, 2, 3
            xparse = xparse.gsub(/\A.*?(CIPM( President| in its meeting)?:?\n*|\((2018|CIPM)\)|de la 103e session) /m, '')
          when 4
            xparse = parse.gsub(/\A.*?, /m, '')
          when 5
            xparse = parse.gsub(/\A.*? (and|et) /m, '')
          else
            r["x-unparsed"] ||= []
            r["x-unparsed"] << parse

            break
          end
        end

        r
      end.sort_by { |i| i["identifier"].split("-").last.to_i }

      if h['resolutions'].length > 0
        index["decisions"][meeting_lang] << h
        # FileUtils.mkdir_p("#{BASE_DIR}/cipm/decisions#{meeting_lang_sfx_dir}")
        # File.write("#{BASE_DIR}/cipm/decisions#{meeting_lang_sfx_dir}/meeting-#{meeting_id}.yml", YAML.dump(h))
      else
        meeting_id = nil
      end
    end

    # index logic: creates an index of all meetings mentioned on the website and
    # their correct references to `decisions-xx` and `meetings-xx` if present.
    # meeting = {
    #   "title" => title,
    #   "url" => href,
    #   "ident" => ident,
    #   "meeting_ref" => yr,
    #   "decisions_ref" => meeting_id,
    # }.compact

    # index["meetings"] << meeting
  end

  # File.write("#{BASE_DIR}/cipm/index#{meeting_lang_sfx_dir}.yml", YAML.dump(index))

  parts = index["meetings"][meeting_lang] + index["decisions"][meeting_lang]
  parts = parts.group_by { |i| i["metadata"]["identifier"].to_s }
  parts = parts.sort_by { |i,| [i.to_i, i] }.to_h # Numeric sort by key

  parts.each do |mid, hs|
    h = {
      "metadata" => hs.first["metadata"],
      "pdf" => hs.first["pdf"],
      "resolutions" => hs.map { |i| i["resolutions"] }.sum([])
    }

    h.delete("pdf") unless h["pdf"]

    FileUtils.mkdir_p("#{BASE_DIR}/cipm/meetings#{meeting_lang_sfx_dir}")
    File.write("#{BASE_DIR}/cipm/meetings#{meeting_lang_sfx_dir}/meeting-#{mid}.yml", YAML.dump(h))
  end
end
